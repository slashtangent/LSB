# Assumed to be run by CMake from the root of the repository.
# Generated files are placed in /build/generated/
# Usage: python tools/generate_rpc_stubs.py "${CMAKE_BINARY_DIR}"

import os
import sys

# ========================
# Define RPC transport structs here
#
# Don't use dynamic arrays or pointers in these structs.
# ========================

rpc_structs = [
    ("TestStruct", "int x", "int y", "float z"),
    ("TestStruct2", "int x", "int y", "float z"),
]

# ========================
# Define RPC calls here
#
# Each of these generates up to 4 functions:
# 1. Send function in origin service (SEND)
# 2. Receive function in destination service (RECV)
# 3. Send function in destination service (SEND)
# 4. Receive function in origin service (RECV)
#
# So each service will end up with up to 2 function calls per RPC call.
#
# Format:
# (
#     (Origin Service, Destination Service),
#     Request Name,
#     Response Arg (string of C++ type),
#     Request Args (List of strings of C++ types, can be an empty list),
# )
#
# C++ types can be numerics, structs, enums, etc. (anything that can be serialized).
# ========================

rpc_calls = [
    # Map to World
    (("map", "world"), "playersOnline", "std::size_t", ["TestStruct"]),
]

# ========================

# Get CMAKE_BINARY_DIR from args
if len(sys.argv) < 2:
    print('Usage: python tools/generate_rpc_stubs.py "${CMAKE_BINARY_DIR}"')
    sys.exit(1)

CMAKE_BINARY_DIR = sys.argv[1]
GENERATED_PATH = f"{CMAKE_BINARY_DIR}/generated"

print(f"Generating RPC stubs in {GENERATED_PATH}")

# Ensure the generated directory exists
if not os.path.exists(f"{CMAKE_BINARY_DIR}/generated"):
    os.makedirs(f"{CMAKE_BINARY_DIR}/generated")

AUTO_GENERATED_WARNING = """// THIS FILE IS AUTO-GENERATED BY `tools/generate_rpc_stubs.py`
// ANY CHANGES MADE HERE WILL BE OVERWRITTEN BY THE GENERATOR\n"""

map_rpc_funcs = []
world_rpc_funcs = []

for rpc_call in rpc_calls:
    origin = rpc_call[0][0]
    dest = rpc_call[0][1]
    func_name = rpc_call[1]
    response_arg = rpc_call[2]
    request_args = rpc_call[3]

    if origin == "map":
        # 1. Send function in origin service (SEND)
        map_rpc_funcs.append(
            f"    virtual void {func_name}_REQ_SEND({', '.join(request_args)}) = 0;"
        )
        # 4. Receive function in origin service (RECV)
        map_rpc_funcs.append(
            f"    virtual auto {func_name}_RES_RECV() -> {response_arg} = 0;"
        )

    if dest == "world":
        # 2. Receive function in destination service (RECV)
        world_rpc_funcs.append(
            f"    virtual auto {func_name}_REQ_RECV({', '.join(request_args)}) -> {response_arg} = 0;"
        )
        # 3. Send function in destination service (SEND)
        world_rpc_funcs.append(
            f"    virtual void {func_name}_RES_SEND({response_arg}) = 0;"
        )

with open(f"{CMAKE_BINARY_DIR}/generated/rpc_structs.h", "w") as f:
    f.write(AUTO_GENERATED_WARNING)
    f.write("#pragma once\n\n")
    f.write("#include <cstddef>\n")
    for struct in rpc_structs:
        f.write(f"\nstruct {struct[0]}\n{{\n")
        for member in struct[1:]:
            f.write(f"    {member};\n")
        f.write("};\n")

with open(f"{CMAKE_BINARY_DIR}/generated/rpc_map_service.h", "w") as f:
    f.write(AUTO_GENERATED_WARNING)
    f.write("#pragma once\n\n")
    f.write('#include "rpc_structs.h"\n\n')
    f.write("#include <cstddef>\n\n")
    f.write("class IRPCMapService\n{\npublic:\n")
    f.write("    virtual ~IRPCMapService() = default;\n\n")
    f.write("\n".join(map_rpc_funcs))
    f.write("\n};\n")

with open(f"{CMAKE_BINARY_DIR}/generated/rpc_world_service.h", "w") as f:
    f.write(AUTO_GENERATED_WARNING)
    f.write("#pragma once\n\n")
    f.write('#include "rpc_structs.h"\n\n')
    f.write("#include <cstddef>\n\n")
    f.write("class IRPCWorldService\n{\npublic:\n")
    f.write("    virtual ~IRPCWorldService() = default;\n\n")
    f.write("\n".join(world_rpc_funcs))
    f.write("\n};\n")
